// ============================================
// EDUQUIZ - BACKEND API (Node.js + Express)
// ============================================

// ============================================
// 1. ARQUIVO: package.json
// ============================================
/*
{
  "name": "eduquiz-backend",
  "version": "1.0.0",
  "description": "Backend API para EduQuiz",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "migrate": "node scripts/migrate.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "pg": "^8.11.3",
    "bcrypt": "^5.1.1",
    "jsonwebtoken": "^9.0.2",
    "dotenv": "^16.3.1",
    "cors": "^2.8.5",
    "express-validator": "^7.0.1",
    "express-rate-limit": "^7.1.5",
    "helmet": "^7.1.0",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "nodemailer": "^6.9.7"
  },
  "devDependencies": {
    "nodemon": "^3.0.2"
  }
}
*/

// ============================================
// 2. ARQUIVO: .env.example
// ============================================
/*
# Database
DATABASE_URL=postgresql://user:password@localhost:5432/eduquiz

# JWT
JWT_SECRET=seu_secret_super_seguro_aqui_mude_isso
JWT_EXPIRES_IN=7d

# Server
PORT=3001
NODE_ENV=development

# Frontend URL (para CORS)
FRONTEND_URL=http://localhost:3000

# Email (opcional)
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=seu_email@gmail.com
SMTP_PASS=sua_senha_app

# Upload (opcional)
MAX_FILE_SIZE=5242880
UPLOAD_DIR=./uploads
*/

// ============================================
// 3. ARQUIVO: server.js
// ============================================

require('dotenv').config();
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const rateLimit = require('express-rate-limit');

// Importar rotas
const authRoutes = require('./routes/auth');
const studentRoutes = require('./routes/students');
const parentRoutes = require('./routes/parents');
const teacherRoutes = require('./routes/teachers');
const questionRoutes = require('./routes/questions');
const quizRoutes = require('./routes/quizzes');
const subjectRoutes = require('./routes/subjects');
const achievementRoutes = require('./routes/achievements');
const notificationRoutes = require('./routes/notifications');

const app = express();
const PORT = process.env.PORT || 3001;

// ============================================
// MIDDLEWARES
// ============================================

// Seguran√ßa
app.use(helmet());

// CORS
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true
}));

// Body parser
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Logging
if (process.env.NODE_ENV === 'development') {
  app.use(morgan('dev'));
}

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: 100, // limite de 100 requisi√ß√µes por IP
  message: 'Muitas requisi√ß√µes deste IP, tente novamente mais tarde.'
});
app.use('/api/', limiter);

// ============================================
// ROTAS
// ============================================

app.get('/', (req, res) => {
  res.json({
    message: 'EduQuiz API',
    version: '1.0.0',
    status: 'online',
    endpoints: {
      auth: '/api/auth',
      students: '/api/students',
      parents: '/api/parents',
      teachers: '/api/teachers',
      questions: '/api/questions',
      quizzes: '/api/quizzes',
      subjects: '/api/subjects'
    }
  });
});

// Rotas da API
app.use('/api/auth', authRoutes);
app.use('/api/students', studentRoutes);
app.use('/api/parents', parentRoutes);
app.use('/api/teachers', teacherRoutes);
app.use('/api/questions', questionRoutes);
app.use('/api/quizzes', quizRoutes);
app.use('/api/subjects', subjectRoutes);
app.use('/api/achievements', achievementRoutes);
app.use('/api/notifications', notificationRoutes);

// Rota 404
app.use('*', (req, res) => {
  res.status(404).json({ error: 'Endpoint n√£o encontrado' });
});

// Error handler
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(err.status || 500).json({
    error: err.message || 'Erro interno do servidor',
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
  });
});

// ============================================
// INICIAR SERVIDOR
// ============================================

app.listen(PORT, () => {
  console.log(`üöÄ Servidor rodando na porta ${PORT}`);
  console.log(`üåç Ambiente: ${process.env.NODE_ENV || 'development'}`);
  console.log(`üìù Documenta√ß√£o: http://localhost:${PORT}/api/docs`);
});

// ============================================
// 4. ARQUIVO: config/database.js
// ============================================

const { Pool } = require('pg');

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

pool.on('error', (err) => {
  console.error('Erro inesperado no cliente do PostgreSQL', err);
  process.exit(-1);
});

// Testar conex√£o
pool.query('SELECT NOW()', (err, res) => {
  if (err) {
    console.error('‚ùå Erro ao conectar ao banco de dados:', err);
  } else {
    console.log('‚úÖ Conectado ao banco de dados:', res.rows[0].now);
  }
});

module.exports = { pool, query: (text, params) => pool.query(text, params) };

// ============================================
// 5. ARQUIVO: middleware/auth.js
// ============================================

const jwt = require('jsonwebtoken');
const { query } = require('../config/database');

const authenticateToken = async (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

  if (!token) {
    return res.status(401).json({ error: 'Token n√£o fornecido' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // Buscar usu√°rio no banco
    const result = await query(
      'SELECT id, email, name, role FROM users WHERE id = $1 AND is_active = true',
      [decoded.userId]
    );

    if (result.rows.length === 0) {
      return res.status(401).json({ error: 'Usu√°rio n√£o encontrado ou inativo' });
    }

    req.user = result.rows[0];
    next();
  } catch (err) {
    return res.status(403).json({ error: 'Token inv√°lido ou expirado' });
  }
};

const authorizeRoles = (...roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ error: 'Acesso negado' });
    }
    next();
  };
};

module.exports = { authenticateToken, authorizeRoles };

// ============================================
// 6. ARQUIVO: routes/auth.js
// ============================================

const express = require('express');
const router = express.Router();
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const { body, validationResult } = require('express-validator');
const { query } = require('../config/database');
const { authenticateToken } = require('../middleware/auth');

// Registro
router.post('/register',
  body('email').isEmail().normalizeEmail(),
  body('password').isLength({ min: 6 }),
  body('name').trim().isLength({ min: 2 }),
  body('role').isIn(['student', 'parent', 'teacher']),
  async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { email, password, name, role, grade, school } = req.body;

    try {
      // Verificar se email j√° existe
      const existingUser = await query('SELECT id FROM users WHERE email = $1', [email]);
      if (existingUser.rows.length > 0) {
        return res.status(400).json({ error: 'Email j√° cadastrado' });
      }

      // Hash da senha
      const passwordHash = await bcrypt.hash(password, 10);

      // Criar usu√°rio
      const userResult = await query(
        'INSERT INTO users (email, password_hash, name, role) VALUES ($1, $2, $3, $4) RETURNING id, email, name, role',
        [email, passwordHash, name, role]
      );

      const user = userResult.rows[0];

      // Criar registro espec√≠fico baseado no role
      if (role === 'student') {
        await query(
          'INSERT INTO students (user_id, grade, school) VALUES ($1, $2, $3)',
          [user.id, grade || 7, school || '']
        );
      } else if (role === 'teacher') {
        await query(
          'INSERT INTO teachers (user_id, school) VALUES ($1, $2)',
          [user.id, school || '']
        );
      } else if (role === 'parent') {
        await query('INSERT INTO parents (user_id) VALUES ($1)', [user.id]);
      }

      // Gerar token
      const token = jwt.sign(
        { userId: user.id, role: user.role },
        process.env.JWT_SECRET,
        { expiresIn: process.env.JWT_EXPIRES_IN }
      );

      res.status(201).json({
        message: 'Usu√°rio criado com sucesso',
        token,
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role
        }
      });
    } catch (err) {
      console.error('Erro ao registrar:', err);
      res.status(500).json({ error: 'Erro ao criar usu√°rio' });
    }
  }
);

// Login
router.post('/login',
  body('email').isEmail().normalizeEmail(),
  body('password').notEmpty(),
  async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { email, password } = req.body;

    try {
      // Buscar usu√°rio
      const result = await query(
        'SELECT * FROM users WHERE email = $1 AND is_active = true',
        [email]
      );

      if (result.rows.length === 0) {
        return res.status(401).json({ error: 'Credenciais inv√°lidas' });
      }

      const user = result.rows[0];

      // Verificar senha
      const validPassword = await bcrypt.compare(password, user.password_hash);
      if (!validPassword) {
        return res.status(401).json({ error: 'Credenciais inv√°lidas' });
      }

      // Atualizar √∫ltimo login
      await query('UPDATE users SET last_login = NOW() WHERE id = $1', [user.id]);

      // Gerar token
      const token = jwt.sign(
        { userId: user.id, role: user.role },
        process.env.JWT_SECRET,
        { expiresIn: process.env.JWT_EXPIRES_IN }
      );

      res.json({
        message: 'Login realizado com sucesso',
        token,
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role
        }
      });
    } catch (err) {
      console.error('Erro ao fazer login:', err);
      res.status(500).json({ error: 'Erro ao fazer login' });
    }
  }
);

// Get current user
router.get('/me', authenticateToken, async (req, res) => {
  try {
    let additionalData = {};

    // Buscar dados adicionais baseado no role
    if (req.user.role === 'student') {
      const studentData = await query(
        'SELECT * FROM students WHERE user_id = $1',
        [req.user.id]
      );
      additionalData = studentData.rows[0];
    } else if (req.user.role === 'teacher') {
      const teacherData = await query(
        'SELECT * FROM teachers WHERE user_id = $1',
        [req.user.id]
      );
      additionalData = teacherData.rows[0];
    } else if (req.user.role === 'parent') {
      const parentData = await query(
        'SELECT * FROM parents WHERE user_id = $1',
        [req.user.id]
      );
      additionalData = parentData.rows[0];
    }

    res.json({
      user: req.user,
      ...additionalData
    });
  } catch (err) {
    console.error('Erro ao buscar usu√°rio:', err);
    res.status(500).json({ error: 'Erro ao buscar dados do usu√°rio' });
  }
});

module.exports = router;

// ============================================
// 7. ARQUIVO: routes/questions.js
// ============================================

const express = require('express');
const router = express.Router();
const { body, validationResult } = require('express-validator');
const { query } = require('../config/database');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

// Criar quest√£o (apenas professores)
router.post('/',
  authenticateToken,
  authorizeRoles('teacher', 'admin'),
  body('question_text').trim().isLength({ min: 10 }),
  body('options').isArray({ min: 2, max: 4 }),
  body('correct_answer').isInt({ min: 0, max: 3 }),
  body('difficulty').isIn(['easy', 'medium', 'hard']),
  body('grade_level').isInt({ min: 1, max: 12 }),
  async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const {
      subject_id,
      question_text,
      options,
      correct_answer,
      explanation,
      difficulty,
      grade_level,
      tags
    } = req.body;

    try {
      // Buscar teacher_id
      const teacherResult = await query(
        'SELECT id FROM teachers WHERE user_id = $1',
        [req.user.id]
      );

      if (teacherResult.rows.length === 0) {
        return res.status(403).json({ error: 'Professor n√£o encontrado' });
      }

      const teacherId = teacherResult.rows[0].id;

      const result = await query(
        `INSERT INTO questions 
        (subject_id, teacher_id, question_text, options, correct_answer, explanation, difficulty, grade_level, tags)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        RETURNING *`,
        [subject_id, teacherId, question_text, JSON.stringify(options), correct_answer, explanation, difficulty, grade_level, tags]
      );

      res.status(201).json({
        message: 'Quest√£o criada com sucesso',
        question: result.rows[0]
      });
    } catch (err) {
      console.error('Erro ao criar quest√£o:', err);
      res.status(500).json({ error: 'Erro ao criar quest√£o' });
    }
  }
);

// Listar quest√µes com filtros
router.get('/', authenticateToken, async (req, res) => {
  const {
    subject_id,
    difficulty,
    grade_level,
    approved,
    search,
    limit = 50,
    offset = 0
  } = req.query;

  try {
    let queryText = `
      SELECT q.*, s.name as subject_name, u.name as teacher_name
      FROM questions q
      LEFT JOIN subjects s ON q.subject_id = s.id
      LEFT JOIN teachers t ON q.teacher_id = t.id
      LEFT JOIN users u ON t.user_id = u.id
      WHERE q.is_active = true
    `;
    const params = [];
    let paramCount = 0;

    if (subject_id) {
      paramCount++;
      queryText += ` AND q.subject_id = $${paramCount}`;
      params.push(subject_id);
    }

    if (difficulty) {
      paramCount++;
      queryText += ` AND q.difficulty = $${paramCount}`;
      params.push(difficulty);
    }

    if (grade_level) {
      paramCount++;
      queryText += ` AND q.grade_level = $${paramCount}`;
      params.push(parseInt(grade_level));
    }

    if (approved !== undefined) {
      paramCount++;
      queryText += ` AND q.approved = $${paramCount}`;
      params.push(approved === 'true');
    }

    if (search) {
      paramCount++;
      queryText += ` AND (q.question_text ILIKE $${paramCount} OR $${paramCount} = ANY(q.tags))`;
      params.push(`%${search}%`);
    }

    queryText += ` ORDER BY q.created_at DESC LIMIT $${paramCount + 1} OFFSET $${paramCount + 2}`;
    params.push(limit, offset);

    const result = await query(queryText, params);

    // Contar total
    const countResult = await query('SELECT COUNT(*) FROM questions WHERE is_active = true');

    res.json({
      questions: result.rows,
      total: parseInt(countResult.rows[0].count),
      limit: parseInt(limit),
      offset: parseInt(offset)
    });
  } catch (err) {
    console.error('Erro ao listar quest√µes:', err);
    res.status(500).json({ error: 'Erro ao listar quest√µes' });
  }
});

// Buscar quest√£o por ID
router.get('/:id', authenticateToken, async (req, res) => {
  try {
    const result = await query(
      `SELECT q.*, s.name as subject_name, u.name as teacher_name
       FROM questions q
       LEFT JOIN subjects s ON q.subject_id = s.id
       LEFT JOIN teachers t ON q.teacher_id = t.id
       LEFT JOIN users u ON t.user_id = u.id
       WHERE q.id = $1`,
      [req.params.id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Quest√£o n√£o encontrada' });
    }

    res.json(result.rows[0]);
  } catch (err) {
    console.error('Erro ao buscar quest√£o:', err);
    res.status(500).json({ error: 'Erro ao buscar quest√£o' });
  }
});

// Atualizar quest√£o
router.put('/:id',
  authenticateToken,
  authorizeRoles('teacher', 'admin'),
  async (req, res) => {
    const { id } = req.params;
    const updates = req.body;

    try {
      // Verificar se o professor √© dono da quest√£o
      const questionResult = await query(
        `SELECT q.* FROM questions q
         JOIN teachers t ON q.teacher_id = t.id
         WHERE q.id = $1 AND t.user_id = $2`,
        [id, req.user.id]
      );

      if (questionResult.rows.length === 0 && req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Sem permiss√£o para editar esta quest√£o' });
      }

      const allowedFields = ['question_text', 'options', 'correct_answer', 'explanation', 'difficulty', 'tags'];
      const updateFields = [];
      const params = [];
      let paramCount = 0;

      Object.keys(updates).forEach(key => {
        if (allowedFields.includes(key)) {
          paramCount++;
          updateFields.push(`${key} = $${paramCount}`);
          params.push(key === 'options' ? JSON.stringify(updates[key]) : updates[key]);
        }
      });

      if (updateFields.length === 0) {
        return res.status(400).json({ error: 'Nenhum campo v√°lido para atualizar' });
      }

      params.push(id);
      const queryText = `UPDATE questions SET ${updateFields.join(', ')}, updated_at = NOW() WHERE id = $${paramCount + 1} RETURNING *`;

      const result = await query(queryText, params);

      res.json({
        message: 'Quest√£o atualizada com sucesso',
        question: result.rows[0]
      });
    } catch (err) {
      console.error('Erro ao atualizar quest√£o:', err);
      res.status(500).json({ error: 'Erro ao atualizar quest√£o' });
    }
  }
);

// Deletar quest√£o
router.delete('/:id',
  authenticateToken,
  authorizeRoles('teacher', 'admin'),
  async (req, res) => {
    try {
      // Soft delete
      const result = await query(
        'UPDATE questions SET is_active = false WHERE id = $1 RETURNING id',
        [req.params.id]
      );

      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Quest√£o n√£o encontrada' });
      }

      res.json({ message: 'Quest√£o removida com sucesso' });
    } catch (err) {
      console.error('Erro ao deletar quest√£o:', err);
      res.status(500).json({ error: 'Erro ao deletar quest√£o' });
    }
  }
);

module.exports = router;

// ============================================
// CONTINUA... (mais arquivos nos pr√≥ximos passos)
// ============================================